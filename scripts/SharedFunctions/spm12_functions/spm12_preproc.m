function results = spm12_preproc ( mri, tpm, afftrans, cfg )
% Combined Segmentation and Spatial Normalisation
%
% FORMAT results = spm12_preproc8(obj)
%
% obj is a structure, and must have the following fields...
%    image    - a structure (array) of handles of individual scans,
%               of the sort returned by spm12_vol.  Data can be
%               multispectral, with N channels, but files must be in
%               voxel-for-voxel alignment.
%    biasfwhm - FWHM of bias field(s). There are N elements, one for
%               each channel.
%    biasreg  - Regularisation of bias field estimation. N elements.
%    tpm      - Tissue probability map data, as generated by
%               spm12_load_priors.  This would represent Kb different
%               tissue classes - including air (background).
%    lkp      - A lookup table indicating which Gaussians should be used
%               with each of the Kb tissue probability maps.  For example,
%               if there are 6 tissue types, with two Gaussians to
%               represent each, except the 5th, which uses 4 Gaussians,
%               then lkp=[1,1,2,2,3,3,4,4,5,5,5,5,6,6].
%    Affine   - a 4x4 affine transformation matrix, such that the mapping
%               from voxels in the individual to those in the template
%               is by tpm.M\Affine*obj.image(1).mat.
%    reg      - Regularisation for the nonlinear registration of the
%               template (tissue probability maps) to the individual.
%    samp     - The distance (mm) between samples.  In order to achieve
%               a reasonable speed, not all voxels in the images are
%               used for the parameter estimation.  Better segmentation
%               would be expected if all were used, but this would be
%               extremely slow.
%    fwhm     - A smoothness estimate for computing a fudge factor that
%               tries to account for spatial covariance in the noise.
%
% obj also has some optional fields...
%    mg       - a 1xK vector (where K is the lengrh of obj.lkp). This
%               represents the mixing proportions within each tissue.
%    mn       - an NxK matrix containing the means of the Gaussians.
%    vr       - an NxNxK matrix containing the covariances of each of
%               the Gaussians.
%    Tbias    - a cell array encoding the parameterisation of each bias
%               field.
%    Twarp    - the encoding of the nonlinear deformation field.
%
% Various estimated parameters are saved as fields of the results
% structure.  Some of these are taken from the input, whereas others
% are estimated or optimised...
%    results.image  = obj.image;
%    results.tpm    = obj.tpm.V;
%    results.Affine = obj.Affine;
%    results.lkp    = obj.lkp;
%    results.MT     = an affine transform used in conjunction with the
%                     parameterisation of the warps.
%    results.Twarp  = obj.Twarp;
%    results.Tbias  = obj.Tbias;
%    results.mg     = obj.mg;
%    results.mn     = obj.mn;
%    results.vr     = obj.vr;
%    results.ll     = Log-likelihood.
%
%_______________________________________________________________________
% The general principles are described in the following paper, but some
% technical details differ.  These include a different parameterisation
% of the deformations, the ability to use multi-channel data and the
% use of a fuller set of tissue probability maps.  The way the mixing
% proportions are dealt with is also slightly different.
%
% Ashburner J & Friston KJ. "Unified segmentation".
% NeuroImage 26(3):839-851 (2005).
%_______________________________________________________________________
% Copyright (C) 2008 Wellcome Trust Centre for Neuroimaging

% John Ashburner
% $Id: spm12_preproc8.m 6431 2015-05-08 18:24:28Z john $

sampling  = cfg.samp;
fwhm      = cfg.fwhm;

tpmtrans  = tpm.M;


% Initialises random number generators to give the same results each time.
rng default

% Sets the stopping criterion.
tol1      = 1e-4;


% Gets the MRI volume and metadata.
mridim    = mri.dim ( 1: 3 );
mritrans  = mri.transform;
volumes   = mri.anatomy;
volumes   = single ( volumes );

numvols   = size ( volumes, 4 );

% volumes      = cat ( 4, volumes, volumes );
% numvols      = 2;
% cfg.biasfwhm = cat ( 1, cfg.biasfwhm, cfg.biasfwhm );
% cfg.biasreg  = cat ( 1, cfg.biasreg,  cfg.biasreg  );
% 
% cfg.lkp = [];

% Gets the transform from MRI voxels to TPM voxels.
transform = tpmtrans \ afftrans * mritrans;


% Gets the voxel size.
vxsize    = sqrt ( sum ( mritrans ( 1: 3, 1: 3 ) .^2 ) );

% Rounds the sampling factor to the nearest voxel.
sampling  = max ( [ 1 1 1 ], round ( sampling * [ 1 1 1 ] ./ vxsize ) );

% Extracts the sampling points.
xs ( :, 1, 1 ) = 1: sampling (1): mridim (1);
ys ( 1, :, 1 ) = 1: sampling (2): mridim (2);
zs ( 1, 1, : ) = 1: sampling (3): mridim (3);

% Samples the MRI volume by the desired factor.
volumes   = volumes ( xs, ys, zs, : );
sampdim   = size ( volumes ( :, :, :, 1 ) );

% Generates a subsampled-to-original voxels transformation.
samptrans = diag ( sampling );
samptrans ( :, 4 ) = 1 - sampling;
samptrans ( 4, 4 ) = 1;

% Calculates the fudge factor for the given Gaussian filter.
dummy     = ( fwhm + mean ( vxsize ) ) / sqrt ( 8 * log (2) );
ffactor   = sqrt ( prod ( 4 * pi * ( dummy ./ vxsize ./ sampling ) .^ 2 + 1 ) );



tiny      = eps * eps;
lkp       = cfg.lkp;
if isempty ( lkp )
    K       = 2000;
    Kb      = numel ( tpm.dat );
    use_mog = false;
else
    K       = numel ( lkp );
    Kb      = max ( lkp );
    use_mog = true;
end






spm12_diffeo('boundary',1);

% Initialise Deformation
%-----------------------------------------------------------------------
% This part is fiddly because of the regularisation of the warps.
% The fact that displacement fields are only parameterised every few
% voxels means that the functions in spm12_diffeo need tweaking to
% account for the difference between the units of displacement and
% the separation of the voxels (if that makes sense).

% More work/thought is needed in terms of adjusting regularisation to
% account for different voxel sizes.  I'm still not satisfied that
% this (rescaling the regularisaiton by prod(vx.*sk)) is optimal.
% The same thing applies to all the nonlinear warping code in SPM.
param  = [ sampling.*vxsize prod(vxsize.*sampling)*ffactor*cfg.reg];

% For multiplying and dividing displacements to map from the subsampled voxel indices
% and the actual image voxel indices.
sk4    = reshape ( sampling, [ 1 1 1 3 ] );

% Takes the warping matrix, if provided.
if isfield ( cfg, 'Twarp' )
    Twarp = cfg.Twarp;
    llr   = -0.5*sum(sum(sum(sum(Twarp.*bsxfun(@times,spm12_diffeo('vel2mom',bsxfun(@times,Twarp,1./sk4),param),1./sk4)))));
    
% Initializes it otherwise.
else
    Twarp = zeros ( cat ( 2, sampdim, 3 ), 'single' );
    llr   = 0;
end



% Calculates the TPM-world z-coordinates of each voxel.
zsr    = bsxfun ( @plus, bsxfun ( @plus, transform (3,1) * xs, transform (3,2) * ys ), transform (3,3) * zs ) + transform (3,4);

% Masks out not valid values (NaN, Inf, 0, -3924 and -1500).
msk    = isfinite ( volumes ) & volumes ~= 0 & volumes ~= -3924 & volumes ~= -1500;
msk    = any ( msk, 4 );

% Masks out the voxels that are below the 5mm line in the TPM-world.
msk    = msk & zsr > 5 / sqrt ( sum ( tpmtrans ( 3, 1: 3 ) .^ 2 ) );

% Masks out the voxels included in a mask, if provided.
if isfield ( cfg, 'msk' )
    msk    = msk & cfg.msk;
end

% Vectorizes and masks the volumes.
vvolumes  = reshape ( volumes, [], numvols );
vvolumes  = vvolumes ( msk (:), : );

% Gets the overall moments for each volume.
mom0   = sum ( msk (:) );
mom1   = squeeze ( sum ( vvolumes ) );
mom2   = squeeze ( sum ( vvolumes .^ 2 ) );

% Constructs a ''Wishart-style prior'' (vr0).
vr0 = diag ( mom2 ./ mom0 - ( mom1 ./ mom0 ) .^ 2 ) / Kb ^ 2;


% Initialise bias correction
%-----------------------------------------------------------------------
args = { 'C', cell( numvols, 1 ), 'B1', [], 'B2', [], 'B3', [], 'T', [], 'll', [] };
if use_mog
    chans = struct( args {:} );
else
    chans = struct( args {:}, 'hist', [], 'lik', [], 'alph', [], 'grad', [], 'lam', [], 'interscal', [] );
end

% Calculates the Gaussian filter for each volume.
dctmats = zeros ( size ( volumes ) );
for vindex = 1: numvols
    
    % Extracts the requested FWHM and regularization of the bias field.
    fwhm    = cfg.biasfwhm ( vindex );
    biasreg = cfg.biasreg  ( vindex );
    
    % Calculates the gaussian length to include 95% of the function.
    sd      = vxsize .* mridim / fwhm;
    gausdim = ceil ( sd * 2 );
    
    % Creates the Gaussian functions.
    krn_x   = exp ( - ( 0: ( gausdim (1) - 1 ) ) .^2 / sd (1) .^ 2 ) / sqrt ( vxsize (1) );
    krn_y   = exp ( - ( 0: ( gausdim (2) - 1 ) ) .^2 / sd (2) .^ 2 ) / sqrt ( vxsize (2) );
    krn_z   = exp ( - ( 0: ( gausdim (3) - 1 ) ) .^2 / sd (3) .^ 2 ) / sqrt ( vxsize (3) );
    
    % Combines the three dimensions of the kernel.
    krn_xyz = kron ( krn_z, kron ( krn_y, krn_x ) ) .^ (-2) * biasreg * ffactor;
    
    % Rewrites the kernel as the diagonal of a sparse matrix.
    krn_xyz = sparse ( 1: length ( krn_xyz ), 1: length ( krn_xyz ), krn_xyz );
    
    % Generates a DCT matrix for each dimension.
    B1  = spm_dctmtx ( mridim (1), gausdim (1), xs );
    B2  = spm_dctmtx ( mridim (2), gausdim (2), ys );
    B3  = spm_dctmtx ( mridim (3), gausdim (3), zs );
    
    % Initializes the bias field.
    if isfield ( cfg, 'Tbias' ) && ~isempty ( cfg.Tbias { vindex } )
        T   = cfg.Tbias { vindex };
    else
        T   = zeros ( gausdim );
    end
    
    % Calculates the initial log-likelihoods.
    ll = double ( -0.5 * T (:)' * krn_xyz * T (:) );
    
    % Calculates the DCT of the bias field.
    dctmats ( :, :, :, vindex ) = exp ( transf ( B1, B2, B3, T ) );
    
    % Stores the sum of all unmasked log of DCT coefficents.
    tmp = log ( dctmats ( :, :, :, vindex ) );
    ll = ll + sum ( double ( tmp ( msk ) ) );
    
    % Saves Gaussian kernel and the initial field.
    chans ( vindex ).C  = krn_xyz;
    chans ( vindex ).T  = T;
    
    % Saves transformation matrix for the current volume.
    chans ( vindex ).B1 = B1;
    chans ( vindex ).B2 = B2;
    chans ( vindex ).B3 = B3;
    
    chans ( vindex ).ll = ll;
end

llrb = sum ( cat ( 1, chans (:).ll ) );


% Vectorizes the and masks the DCT matrix.
vdctmats = reshape  ( dctmats, [], numvols );
vdctmats = vdctmats ( msk (:), : );

% Calculates the 'CR' matrix.
vcrmats  = vvolumes .* vdctmats;

if isfield(cfg,'wp')
    wp = cfg.wp;
else
    wp = ones(1,Kb)/Kb;
end
for iter=1:30
    
    % Calculates the warped coordinates of each voxel.
    xsw    = bsxfun ( @plus, xs, Twarp ( :, :, :, 1 ) );
    ysw    = bsxfun ( @plus, ys, Twarp ( :, :, :, 2 ) );
    zsw    = bsxfun ( @plus, zs, Twarp ( :, :, :, 3 ) );
    
    % Transforms the voxel coordinates to TPM-space.
    xsr    = transform (1,1) * xsw + transform (1,2) * ysw + transform (1,3) * zsw + transform (1,4);
    ysr    = transform (2,1) * xsw + transform (2,2) * ysw + transform (2,3) * zsw + transform (2,4);
    zsr    = transform (3,1) * xsw + transform (3,2) * ysw + transform (3,3) * zsw + transform (3,4);
    
    % Calculates the a-priori probability of each voxel for each tissue.
    priors = spm12_sample_priors8 ( tpm, double ( xsr ( msk ) ), double ( ysr ( msk ) ), double ( zsr ( msk ) ) );
    priors = cat ( 2, priors {:} );
    
    % First stimations.
    if iter == 1
        
        % Estiamtion for intensity distribution parameters
        if use_mog
            
            % Loads the Gaussian parameters, if provided.
            if isfield ( cfg, 'mg' ) && isfield ( cfg, 'mn' ) && isfield ( cfg, 'vr' )
                mg = cfg.mg;
                mn = cfg.mn;
                vr = cfg.vr;
                
            % Otherwise estimates the Gaussian parameters.
            else

                % Begin with moments:
                K        = Kb;
                lkp      = 1: Kb;
                
                % Calculates the moments from the a-priori probability.
                mm0      = sum ( priors )';
                mm1      = ( priors' * vcrmats )';
                mm2      = cellfun ( @(prior) bsxfun ( @times, prior, vcrmats )' * vcrmats, num2cell ( priors, [ 1 K ] ), 'UniformOutput', false );
                mm2      = cat ( 3, mm2 {:} );
                
                
                % Calculates the mean and the variance.
                mn       = bsxfun ( @rdivide, mm1, mm0' + tiny );
                
                % ¿?¿?
                vr = zeros(numvols,numvols,Kb);
                vr1 = zeros(numvols,numvols);
                for k1=1:Kb
                   %vr(:,:,k1) = (mm2(:,:,k1) - mm1(:,k1)*mm1(:,k1)'/mm0(k1))/(mm0(k1)+tiny);
                    vr1 = vr1 + (mm2(:,:,k1) - mm1(:,k1)*mm1(:,k1)'/mm0(k1));
                end
                vr1 = (vr1+numvols*vr0)/(sum(mm0)+numvols);
                for k1=1:Kb
                    vr(:,:,k1) = vr1;
                end
                
                mg = ones ( Kb, 1 );
            end
            
        % Estimation for histograms.
        else
            for vindex = 1: numvols
                
                % Gets the current volume.
                vvolume = vvolumes ( :, vindex );
                vcrmat  = vcrmats  ( :, vindex );
                
                % Gets the maximum and minimum values.
                maxval  = nanmax ( vvolume );
                minval  = nanmin ( vvolume );
                
chans(vindex).interscal = [1 minval; 1 maxval]\[1;K];
                
                % Accounts for bias correction effects.
                maxval  = max ( maxval * 1.5, -minval * 0.05 );
                minval  = min ( minval * 1.5, -maxval * 0.05 );
                
                % Normalizes the CR matrix between 1 and K.
                nvcrmat = round ( ( vcrmat - minval ) / ( maxval - minval ) * ( K - 1 ) + 1 );
                
                % Generates a ponderated histogram.
%                 h0      = cellfun ( @(prior) accumarray ( nvcrmat, prior, [ K 1 ] ), priors, 'UniformOutput', false );
                h0      = cellfun ( @(prior) accumarray ( nvcrmat, prior, [ K 1 ] ), num2cell ( priors, [ 1 K ] ), 'UniformOutput', false );
                h0      = cat ( 2, h0 {:} );
                
                chans ( vindex ).hist = h0;
            end
        end
    end

    for iter1=1:8
        if use_mog
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Estimate cluster parameters
            %------------------------------------------------------------
            for subit=1:20
                
                % Stores the value of 'll' for comparation purposes.
                oll     = ll;
                
                % Updates the a-priori data.
                [ q, dll ] = latent ( vvolumes, vdctmats, mg, mn, vr, priors, lkp, wp );
                ll      = llr + llrb + dll;
                
                % Updates the moments.
                mom0    = sum ( q )';
                mom1    = ( q' * vcrmats )';
                mom2    = cellfun ( @(prior) bsxfun ( @times, prior, vcrmats )' * vcrmats, num2cell ( q, [ 1 K ] ), 'UniformOutput', false );
                mom2    = cat ( 3, mom2 {:} );
                
                % Calculates the means and variance from the moments.
                mgm     = 1 ./ ( priors * wp' )' * priors;
                mn      = bsxfun ( @rdivide, mom1, mom0' + tiny );
                
                % Mixing proportions, Means and Variances from moments
                for k=1:K
                    tmp       = mom0(lkp==lkp(k));
                    mg(k)     = (mom0(k)+tiny)/sum(tmp+tiny);  % US eq. 27 (partly)
                    mn(:,k)   = mom1(:,k)/(mom0(k)+tiny);      % US eq. 23
                    vr(:,:,k) = (mom2(:,:,k) - mom1(:,k)*mom1(:,k)'/mom0(k) + numvols*vr0)/(mom0(k)+numvols); % US eq. 25
                end
                for k1=1:Kb
                    wp(k1) = (sum(mom0(lkp==k1)) + 1)/(mgm(k1) + Kb); % bias the solution towards 1
                end
                wp = wp/sum(wp);
                
                % Makes sure that variance is positive.
%                 vr = max ( vr, tiny );
                
                % If the improvement is small skips to the next step.
                if subit > 1 && ll - oll < tol1 * sum ( msk (:) ), break, end
            end
        else
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            % Estimate histogram parameters
            %------------------------------------------------------------

            % Compute regularisation for histogram smoothing
            for vindex=1:numvols
                for k1=1:Kb
                    chans(vindex).lam(k1) = Kb^2*double(vr0(numvols,numvols)*chans(vindex).interscal(2)^2);
                end
            end

            for subit=1:20
                
                % Stores the value of 'll' for comparation purposes.
                oll  = ll;
                
                for vindex=1:numvols
                    chans(vindex).lik  = spm12_smohist(chans(vindex).hist,chans(vindex).lam);
                    chans(vindex).lik  = chans(vindex).lik*chans(vindex).interscal(2);
                    chans(vindex).alph = log(chans(vindex).lik+eps);
                    chans(vindex).hist = zeros(K,Kb);
                end
                
                % Updates the a-priori data and 'll'.
                [ q, dll ] = latent_nonpar ( vvolumes, vdctmats, chans, priors, wp );
                ll = llr + llrb + dll;
                
                for vindex = 1: numvols
                    
                    % Scales the CR matrix.
                    nvcrmat = vcrmats ( :, vindex ) * chans ( vindex ).interscal (2) + chans ( vindex ).interscal (1);
                    nvcrmat = min ( max ( round ( nvcrmat ), 1 ), K );
                    
                    % Calculates the histogram for each tissue.
                    vhist   = cellfun ( @(prior) accumarray ( nvcrmat, prior, [ K 1 ] ), num2cell ( q, [ 1 K ] ), 'UniformOutput', false );
                    vhist   = cat ( 2, vhist {:} );
                    
                    chans ( vindex ).hist = vhist;
                end
                
                mgm = 1 ./ ( priors * wp' )' * priors;
                wp  = ( sum ( chans (1).hist ) + 1 ) ./ ( mgm + Kb );
                wp  = wp / sum ( wp );
                
                % If the improvement is small skips to the next step.
                if subit > 1 && ll - oll < tol1 * sum ( msk (:) ), break, end
            end
            for vindex=1:numvols
                chans(vindex).lik  = spm12_smohist(chans(vindex).hist,chans(vindex).lam);
                chans(vindex).lik  = chans(vindex).lik*chans(vindex).interscal(2);
                chans(vindex).alph = log(chans(vindex).lik+eps);
                chans(vindex).grad1 = convn(chans(vindex).alph,[0.5 0 -0.5]'*chans(vindex).interscal(2),  'same');
                chans(vindex).grad2 = convn(chans(vindex).alph,[1  -2  1  ]'*chans(vindex).interscal(2)^2,'same');
            end
        end
        
        % If the improvement is small skips to the next step.
        if iter1 > 1 && ll - ooll < 2 * tol1 * sum ( msk (:) ), break; end
        
        % Stores the value of 'll' for comparation purposes.
        ooll = ll;


        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Estimate bias
        % Note that for multi-spectral data, the covariances among
        % channels are not computed as part of the second derivatives.
        % The aim is to save memory, and maybe make the computations
        % faster.
        %------------------------------------------------------------

        if use_mog
            pr = zeros(size(vr)); % Precisions
            for k=1:K, pr(:,:,k) = inv(vr(:,:,k)); end
        end

        for subit=1:1
            for vindex=1:numvols
                if ~numel ( chans ( vindex ).T ), continue, end
                
                gausdim  = numel ( chans ( vindex ).T );
                
                if use_mog
                    
                    % Updates the a-priori data.
                    q = latent ( vvolumes, vdctmats, mg, mn, vr, priors, lkp, wp );
                    
                    tmp  = bsxfun ( @plus, -vcrmats ( :, vindex ), permute ( mn, [ 3 2 1 ] ) );
                    tmp  = bsxfun ( @times, tmp, permute ( pr ( :, vindex, : ), [ 2 3 1 ] ) );
                    w0   = sum ( tmp, 3 );
                    w1   = q .* w0;
                    w1   = sum ( w1, 2 );
                    w2   = bsxfun ( @times, q, permute ( pr ( vindex, vindex, : ), [ 1 3 2 ] ) );
                    w2   = sum ( w2, 2 );
                    
                    wt1  = zeros ( sampdim );
                    wt2  = zeros ( sampdim );
                    wt1  ( msk ) = - ( 1 + vcrmats ( :, vindex ) .* w1 );
                    wt2  ( msk ) = vcrmats ( :, vindex ) .* vcrmats ( :, vindex ) .* w2 + 1;
                else
                    
                    % Updates the a-priori data.
                    q   = latent_nonpar ( vvolumes, vdctmats, chans, priors, wp );
                    
                    % Normalizes the CR matrix.
                    ins     = [ chans.interscal ];
                    vcrmat  = vcrmats ( :, vindex );
                    nvcrmat = bsxfun ( @times, vcrmat, ins ( 2, vindex ) );
                    nvcrmat = bsxfun ( @plus, nvcrmat, ins ( 1, vindex ) );
                    nvcrmat = min ( max ( round ( nvcrmat ), 1 ), K );
                    
                    gr1     = chans ( vindex ).grad1 ( nvcrmat, : );
                    gr2     = chans ( vindex ).grad2 ( nvcrmat, : );
                    gr2     = min ( gr2, 0 );
                    
                    wt1     = zeros ( sampdim );
                    wt2     = zeros ( sampdim );
                    wt1 ( msk ) = sum ( -q .* ( bsxfun ( @times, gr1, vcrmat ) + 1 ), 2 );
                    wt2 ( msk ) = sum ( q .* ( 1 - bsxfun ( @times, gr2, vcrmat .^ 2 ) ), 2 );
                end
                
                B1    = chans ( vindex ).B1;
                B2    = chans ( vindex ).B2;
                B3    = chans ( vindex ).B3;
                
                
                % Compute objective function and its 1st and second derivatives
                Alpha = zeros ( gausdim, gausdim ); % Second derivatives
                Beta  = zeros ( gausdim, 1 );  % First derivatives
                
                for z = 1: length ( zs )
                    Beta  = Beta  + kron ( B3 ( z, : )',               spm_krutil ( wt1 ( :, :, z ), B1, B2, 0 ) );
                    Alpha = Alpha + kron ( B3 ( z, : )' * B3 ( z, : ), spm_krutil ( wt2 ( :, :, z ), B1, B2, 1 ) );
                end
                clear wt1 wt2 b3
                
                % Stores the value of 'll' for comparation purposes.
                oll     = ll;
                
                C       = chans(vindex).C; % Inverse covariance of priors
                
                % Gauss-Newton update of bias field parameters
                Update  = reshape((Alpha + C)\(Beta + C*chans(vindex).T(:)),size(chans(vindex).T));
                clear Alpha Beta
                
                
                armijo = 1.0;
                for line_search=1:12
                    
                    % Updates the bias field.
                    T  = chans ( vindex ).T - armijo * Update;
                    B1 = chans ( vindex ).B1;
                    B2 = chans ( vindex ).B2;
                    B3 = chans ( vindex ).B3;
                    
                    % Calculates the DCT of the bias field.
                    dctmats ( :, :, :, vindex ) = exp ( transf ( B1, B2, B3, T ) );
                    
                    % Vectorizes the DCT matrix and masks.
                    vdctmats = reshape  ( dctmats, [], numvols );
                    vdctmats = vdctmats ( msk (:), : );
                    
                    % Re-calculates the 'CR' matrix.
                    vcrmats  = vvolumes .* vdctmats;
                    
                    chans ( vindex ).ll = double ( -0.5 * T (:)' * C * T (:) ) + sum ( log ( vdctmats ( :, vindex ) ) );
                    
                    % Calculates 'll'.
                    if use_mog
                        [ ~, dll ] = latent ( vvolumes, vdctmats, mg, mn, vr, priors, lkp, wp );
                    else
                        [ ~, dll ] = latent_nonpar ( vvolumes, vdctmats, chans, priors, wp );
                    end
                    
                    llrb = sum ( cat ( 1, chans.ll ) );
                    ll1 = llr + llrb + dll;
                    
                    % If the results are better accepts the solution.
                    if ll1 >= ll
                        ll        = ll1;
                        chans(vindex).T = T;
                        break
                        
                        % Otherwise keeps searching inwards.
                    else
                        armijo    = armijo * 0.5;
                    end
                end
            end
            
            % If the improvement is small skips to the next step.
            if subit > 1 && ll - oll < tol1 * sum ( msk (:) ), break, end
        end
        
        if iter==1 && iter1==1
            % Most of the log-likelihood improvements are in the first iteration.
            % Show only improvements after this, as they are more clearly visible.
            
           if use_mog && numel(cfg.lkp) ~= numel(lkp)
                mn1 = mn;
                vr1 = vr;
                lkp = cfg.lkp;
                K   = numel(lkp);
                Kb  = max(lkp);

                % Use moments to compute means and variances, and then use these
                % to initialise the Gaussians
                mg = ones(K,1)/K;
                mn = ones(numvols,K);
                vr = zeros(numvols,numvols,K);

                for k1=1:Kb
                    % A crude heuristic to replace a single Gaussian by a bunch of Gaussians
                    % If there is only one Gaussian, then it should be the same as the
                    % original distribution.
                    kk  = sum(lkp==k1);
                    w   = 1./(1+exp(-(kk-1)*0.25))-0.5;
                    mn(:,lkp==k1)   = sqrtm(vr1(:,:,k1))*randn(numvols,kk)*w + repmat(mn1(:,k1),[1,kk]);
                    vr(:,:,lkp==k1) = repmat(vr1(:,:,k1)*(1-w),[1,1,kk]);
                    mg(lkp==k1)     = 1/kk;
                end
            end
        end
    end
    
    
    
    % Estimates the deformations.
    if use_mog
        
        % Computes the log-likelihoods.
        qt     = log_likelihoods ( vvolumes, vdctmats, mg, mn, vr );
        max_qt = max ( qt, [], 2 );
        qt     = exp ( bsxfun ( @minus, qt, max_qt ) );
        
        q      = zeros ( sum ( msk (:) ), Kb );
        for k1 = 1: Kb
             q ( :, k1 ) = sum ( qt ( :, lkp == k1 ), 2 );
        end
        
        ll_const = sum ( max_qt );
    else
        
        % Computes the log-likelihoods.
        q      = log_likelihoods_nonpar ( vvolumes, vdctmats, chans );
        max_q  = max ( q, [], 2 );
        q      = exp ( bsxfun ( @minus, q, max_q ) );
        
        ll_const = sum ( max_q );
    end
    
    B      = bsxfun ( @times, priors, wp );
    B      = bsxfun ( @times, B, 1 ./ sum ( B, 2 ) );
    ll     = ll_const + llr + llrb + sum ( log ( sum ( q .* B + tiny, 2 ) ), 1 );
    
    % Updates the probabilities.
    priors = q;
    
    % Stores the value of 'll' for comparation purposes.
    oll = ll;
    
    for subit=1:3
        
        % Calculates the warped coordinates of each voxel.
        xsw    = bsxfun ( @plus, xs, Twarp ( :, :, :, 1 ) );
        ysw    = bsxfun ( @plus, ys, Twarp ( :, :, :, 2 ) );
        zsw    = bsxfun ( @plus, zs, Twarp ( :, :, :, 3 ) );
        
        % Transforms the voxel coordinates to TPM-space.
        xsr    = transform (1,1) * xsw + transform (1,2) * ysw + transform (1,3) * zsw + transform (1,4);
        ysr    = transform (2,1) * xsw + transform (2,2) * ysw + transform (2,3) * zsw + transform (2,4);
        zsr    = transform (3,1) * xsw + transform (3,2) * ysw + transform (3,3) * zsw + transform (3,4);
        
        % Calculates the a-priori probabilities and their derivatives.
        [ b, db1, db2, db3 ] = spm12_sample_priors8 ( tpm, double ( xsr ( msk ) ), double ( ysr ( msk ) ), double ( zsr ( msk ) ) );
        clear xsw ysw zsw
        clear xsr ysr zsr

        % Joins all the volumes information in a single matrix.
        b      = cat ( 2, b   {:} );
        db1    = cat ( 2, db1 {:} );
        db2    = cat ( 2, db2 {:} );
        db3    = cat ( 2, db3 {:} );
        
        % Scales the probabilies.
        b      = bsxfun ( @times, wp, b   );
        db1    = bsxfun ( @times, wp, db1 );
        db2    = bsxfun ( @times, wp, db2 );
        db3    = bsxfun ( @times, wp, db3 );
        
        s      = sum ( b, 2 );
        ds1    = sum ( db1, 2 );
        ds2    = sum ( db2, 2 );
        ds3    = sum ( db3, 2 );
        
        b      = bsxfun ( @rdivide, b, s );
        db1    = bsxfun ( @rdivide, db1 - bsxfun ( @times, b, ds1 ), s );
        db2    = bsxfun ( @rdivide, db2 - bsxfun ( @times, b, ds2 ), s );
        db3    = bsxfun ( @rdivide, db3 - bsxfun ( @times, b, ds3 ), s );
        clear s ds1 ds2 ds3
        
        % Trnsforms the sample voxels to SPM-world coordinates.
        MM     = transform * samptrans;
          
        p      = priors .* b;
        dp1    = priors .* ( MM (1,1) * db1 + MM (2,1) * db2 + MM (3,1) * db3 );
        dp2    = priors .* ( MM (1,2) * db1 + MM (2,2) * db2 + MM (3,2) * db3 );
        dp3    = priors .* ( MM (1,3) * db1 + MM (2,3) * db2 + MM (3,3) * db3 );
        clear b db1 db2 db3
        
        p      = sum ( p, 2 );
        dp1    = sum ( dp1, 2 );
        dp2    = sum ( dp2, 2 );
        dp3    = sum ( dp3, 2 );
        
        % Writes the derivatives in matrix form.
        Mdp1   = zeros ( sampdim );
        Mdp2   = zeros ( sampdim );
        Mdp3   = zeros ( sampdim );
        
        Mdp1 ( msk ) = dp1 ./ p;
        Mdp2 ( msk ) = dp2 ./ p;
        Mdp3 ( msk ) = dp3 ./ p;
        
        % Stores the first and second derivatives.
        Beta   = cat ( 4, -Mdp1, -Mdp2, -Mdp3 );
        Alpha  = cat ( 4, Mdp1 .* Mdp1, Mdp2 .* Mdp2, Mdp3 .* Mdp3, Mdp1 .* Mdp2, Mdp1 .* Mdp3, Mdp2 .* Mdp3 );
        
        % Heavy-to-light regularisation
        if ~isfield(cfg,'Twarp')
            switch iter
            case 1
                prm = [param(1:3) 256*param(4:8)];
            case 2
                prm = [param(1:3) 128*param(4:8)];
            case 3
                prm = [param(1:3)  64*param(4:8)];
            case 4
                prm = [param(1:3)  32*param(4:8)];
            case 5
                prm = [param(1:3)  16*param(4:8)];
            case 6
                prm = [param(1:3)  8*param(4:8)];
            case 7
                prm = [param(1:3)  4*param(4:8)];
            case 8
                prm = [param(1:3)  2*param(4:8)];
            otherwise
                prm = [param(1:3)    param(4:8)];
            end
        else
            prm = [param(1:3)   param(4:8)];
        end
        
        % Makes sure that the derivatives are single-precision.
        Beta   = single ( Beta );
        Alpha  = single ( Alpha );
        
        % Add in the first derivatives of the prior term
        Beta   = Beta  + spm12_diffeo('vel2mom',bsxfun(@times,Twarp,1./sk4),prm);

        % Gauss-Newton increment
        Update = bsxfun(@times,spm12_diffeo('fmg',Alpha,Beta,[prm 2 2]),sk4);

        % Line search to ensure objective function improves
        armijo = 1.0;
        for line_search=1:12
            
            % Updates the warp field.
            Twarp1 = Twarp - armijo * Update;
            
            % Recompute objective function
            llr1   = -0.5*sum(sum(sum(sum(Twarp1.*bsxfun(@times,spm12_diffeo('vel2mom',bsxfun(@times,Twarp1,1./sk4),prm),1./sk4)))));
            
            
            
            % Calculates the warped coordinates of each voxel.
            xsw    = bsxfun ( @plus, xs, Twarp1 ( :, :, :, 1 ) );
            ysw    = bsxfun ( @plus, ys, Twarp1 ( :, :, :, 2 ) );
            zsw    = bsxfun ( @plus, zs, Twarp1 ( :, :, :, 3 ) );
            
            % Transforms the voxel coordinates to TPM-space.
            xsr    = transform (1,1) * xsw + transform (1,2) * ysw + transform (1,3) * zsw + transform (1,4);
            ysr    = transform (2,1) * xsw + transform (2,2) * ysw + transform (2,3) * zsw + transform (2,4);
            zsr    = transform (3,1) * xsw + transform (3,2) * ysw + transform (3,3) * zsw + transform (3,4);
            
            % Calculates the a-priori probability of each voxel.
            b      = spm12_sample_priors8 ( tpm, double ( xsr ( msk ) ), double ( ysr ( msk ) ), double ( zsr ( msk ) ) );
            b      = cat ( 2, b {:} );
            b      = bsxfun ( @times, b, wp );
            b      = bsxfun ( @rdivide, b, sum ( b, 2 ) );
            
            ll1    = llr1 + llrb + ll_const + sum ( log ( sum ( priors .* b, 2 ) ) );
            
            % If the results are better accepts the solution.
            if ll1 > ll
                ll     = ll1;
                llr    = llr1;
                Twarp  = Twarp1;
                break
                
            % Otherwise keeps searching inwards.
            else
                armijo = armijo * 0.75;
            end
        end
        clear Alpha Beta
        
        % If the improvement is small skips to the next step.
        if ll - oll < tol1 * sum ( msk (:) ), break, end
        
        % Stores the value of 'll' for comparation purposes.
        oll = ll;
    end
    
    % If the improvement is small finishes.
    if iter > 9 && ll - ooll < 2 * tol1 * sum ( msk (:) ), break, end
end

% Save the results
results.mri    = mri;
results.tpm    = tpm;
results.Affine = afftrans;
results.lkp    = lkp;
results.MT     = samptrans;
results.Twarp  = Twarp;
results.Tbias  = {chans(:).T};
results.wp     = wp;
if use_mog
    results.mg     = mg;
    results.mn     = mn;
    results.vr     = vr;
else
    for vindex=1:numvols
        results.intensity(vindex).lik       = chans(vindex).lik;
        results.intensity(vindex).interscal = chans(vindex).interscal;
    end
end
results.ll      = ll;
%=======================================================================

%=======================================================================
function t = transf(B1,B2,B3,T)

% Reserves memory for the DCT.
t = zeros ( size ( B1, 1 ), size ( B2, 1 ), size ( B3, 1 ) );

if isempty ( T ), return, end

d2 = size ( T );
t1 = reshape ( T, d2 (1) * d2 (2), d2 (3) );
t1 = t1 * B3';
t1 = reshape ( t1, d2 (1), d2 (2), [] );
for z = 1: size ( B3, 1 )
    t ( :, :, z ) = B1 * t1 ( :, :, z ) * B2';
end
%=======================================================================

%=======================================================================
function L = log_likelihoods(f,bf,mg,mn,vr)
K  = numel(mg);
N  = size(f,2);
M  = size(f,1);
cr = reshape ( f .* bf, [], N );
L  = zeros(M,K);
for k=1:K
    C      = chol(vr(:,:,k));
    d      = bsxfun(@minus,cr,mn(:,k)')/C;
    L(:,k) = log(mg(k)) - (N/2)*log(2*pi) - sum(log(diag(C))) - 0.5*sum(d.*d,2);
end
%=======================================================================

%=======================================================================
function L = log_likelihoods_nonpar(f,bf,chan)
K  = size(chan(1).lik,1);
Kb = size(chan(1).lik,2);
N  = numel(chan);
L  = zeros(size(f,1),Kb);
ins = [ chan.interscal ];
tmp = bsxfun ( @times, f .* bf, ins ( 2, : ) );
tmp = bsxfun ( @plus, tmp, ins ( 1, : ) );
tmp = min ( max ( round ( tmp ), 1 ), K );
for n=1:N
   L=L+chan(n).alph(tmp(:,n),:); 
end
%=======================================================================

%=======================================================================
function B = log_spatial_priors(B,wp)
B   = bsxfun(@times,B,wp);
B   = log(bsxfun(@times,B,1./sum(B,2)));
%=======================================================================

%=======================================================================
function [Q,ll] = safe_softmax(Q)
maxQ = max(Q,[],2);
Q    = exp(bsxfun(@minus,Q,maxQ));
sQ   = sum(Q,2);
ll   = sum(log(sQ)+maxQ);
Q    = bsxfun(@rdivide,Q,sQ);
%=======================================================================

%=======================================================================
function [Q,ll] = latent(f,bf,mg,mn,vr,B,lkp,wp)
B   = log_spatial_priors(B,wp);
Q   = log_likelihoods(f,bf,mg,mn,vr);
Kb  = max(lkp);
for k1=1:Kb
    for k=find(lkp==k1)
        Q(:,k) = Q(:,k) + B(:,k1);
    end
end
[Q,ll] = safe_softmax(Q);
%=======================================================================

%=======================================================================
function [Q,ll] = latent_nonpar(f,bf,chan,B,wp)
B      = log_spatial_priors(B,wp);
Q      = log_likelihoods_nonpar(f,bf,chan);
Q      = Q + B;
[Q,ll] = safe_softmax(Q);
%=======================================================================
